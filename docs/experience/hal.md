# HAL层开发

## riscv平台的浮点支持

我们在运行 `busybox sh`时发现riscv平台时会在浮点指令上报非法指令异常，发现是AxHal层没有实现浮点保存和恢复操作，没有设置浮点相关的标志位。

Riscv64平台提供了一些浮点寄存器，并为它们设计了4种浮点状态，以追踪当前进程的浮点寄存器使用情况，从而为保存/恢复浮点状态提供指导。

具体而言，在CSR寄存器sstatus中存在两位的FS字段，有以下几种取值：

- off：禁用浮点支持，表现为程序执行浮点指令或访问浮点寄存器时触发非法指令异常。这主要用于在OS不支持浮点状态保存恢复时避免误执行了需要浮点功能的程序。
- initial：初始状态。意思是该进程从未执行过浮点操作，因此在保存状态时无需保存浮点寄存器，在恢复状态时只需要将浮点寄存器设置为常量而无需访存。（这里恢复状态时什么也不做不会影响正确性，但是设置为常量有助于避免侧信道攻击）
- clean：自从上次恢复浮点状态以来，浮点寄存器未发生过更改。因此我们在保存状态时无需保存浮点寄存器（用上次保存的值即可）。
- dirty：自从上次恢复浮点状态以来，浮点寄存器发生过更改。因此我们需要保存浮点状态。

在此之前，FS的状态为"off"，而某些程序在执行类似 `memset`的库函数时会使用浮点/向量操作来快速初始化内存等，访问了浮点寄存器导致触发了非法指令异常。

我为 `axhal`模块编写了代码，完整支持了riscv64平台下的浮点状态保存和恢复操作。在经过审核后，代码合并进入了主线。[feat[axhal]: implement floating point support for riscv by eternalcomet · Pull Request #27 · oscomp/arceos](https://github.com/oscomp/arceos/pull/27)
